package SwordByClass.Math;

public class Solution {
    /**
     * 39. 数组中出现次数超过一半的数字
     * 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
     * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
     * 示例 1:
     * 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
     * 输出: 2
     */
    public int majorityElement(int[] nums) {
        int winner = nums[0], count=0;
        for (int num : nums) {
            if (num == winner) count++;
            else {
                if (count == 0){
                    winner = num;
                    count++;
                }else {
                    count--;
                }
            }
        }
        return winner;
    }

    /**
     * 62. 圆圈中最后剩下的数字
     * 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。
     * 求出这个圆圈里剩下的最后一个数字。
     * 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，
     * 因此最后剩下的数字是3。
     * 示例 1：
     * 输入: n = 5, m = 3
     * 输出: 3
     * 示例 2：
     * 输入: n = 10, m = 17
     * 输出: 2
     */
    public int lastRemaining(int n, int m) {
        // TODO: 2023/1/16 推导过程如下，最好还是直接记住结论：dp[i] = (dp[i-1]+m)%n
        // dp[i] 表示 i 个数的约瑟夫环问题，删除第 m 个数字，也就是索引为 m-1 的
        // 由于是环，因此删除的实际是第 m%i 个数字，也就是索引为 (m-1)%i的，之后的序列应该从索引为m%i开始
        // 令 t=m%i, 剩下的序列应该为：t,t+1,t+2,...,0,1,2,...,t-3,t-2
        // 删除后，此时变为了规模为 i-1 的约瑟夫环问题
        // 规模为 i-1 的约瑟夫环问题的序列为：0,1,2,...,i-2，和上面的一一对应，不难发现
        // 对于该序列中的任意数 x，对应上面的 (x+t)%i
        // 因此，可得状态转移方程：dp[i] = (dp[i-1]+t)%i = (dp[i-1]+m%i)%i = (dp[i-1]+m)%i
        // 最终答案为dp[n]
        /*int[] dp = new int[n+1];
        dp[1] = 0; // 一个数的约瑟夫环问题，删除第几个数最后都不会有数，也就是0
        for (int i = 2; i < dp.length; i++) {
            dp[i] = (dp[i-1]+m)%i;
        }
        return dp[n];*/
        // 进一步，发现过程中只用到了dp[i] dp[i-1]，因此，可以不使用dp数组
        int a = 0;
        for (int i = 2; i < n+1; i++) {
            a = (a+m)%i;
        }
        return a;
    }
}
