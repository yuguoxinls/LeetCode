package LeetCodeByClass.DataStructure.BitOperations;

public class Solution {
    /**
     * 1. 汉明距离
     * 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
     * 给你两个整数 x 和 y，计算并返回它们之间的汉明距离。
     * 示例 1：
     * 输入：x = 1, y = 4
     * 输出：2
     * 解释：
     * 1   (0 0 0 1)
     * 4   (0 1 0 0)
     *        ↑   ↑
     * 上面的箭头指出了对应二进制位不同的位置。
     * 示例 2：
     * 输入：x = 3, y = 1
     * 输出：1
     */
    public int hammingDistance(int x, int y) {
        int tmp = x ^ y;
        int ans = 0;
        while (tmp != 0){
            ans += tmp & 1;
            tmp = tmp >>> 1;
        }
        return ans;
    }

    /**
     * 2. 只出现一次的数字
     * 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
     * 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
     * 示例 1 ：
     * 输入：nums = [2,2,1]
     * 输出：1
     * 示例 2 ：
     * 输入：nums = [4,1,2,1,2]
     * 输出：4
     * 示例 3 ：
     * 输入：nums = [1]
     * 输出：1
     */
    public int singleNumber(int[] nums) { // 利用 x^x = 0, x^0 = x
        int ans = 0;
        for (int num : nums) {
            ans = ans ^ num;
        }
        return ans;
    }

    /**
     * 3. 丢失的数字
     * 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
     * 示例 1：
     * 输入：nums = [3,0,1]
     * 输出：2
     * 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
     * 示例 2：
     * 输入：nums = [0,1]
     * 输出：2
     * 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
     * 示例 3：
     * 输入：nums = [9,6,4,2,3,5,7,0,1]
     * 输出：8
     * 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
     * 示例 4：
     * 输入：nums = [0]
     * 输出：1
     * 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
     */
    public int missingNumber(int[] nums) {
        /*Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        for (int i = 0; i <= nums.length; i++) {
            if (!set.contains(i)) return i;
        }
        return -1;*/
        // TODO: 2022/12/30 位运算
        // 令n = nums.length，在nums的后面添加从0到n的所有数，这样就一共有n+(n+1)=2n+1个数
        // 由于数组中缺少从0到n的所有数中的一个，这样的话，这2n+1个数中，只有一个数出现了一次，其余的数都出现了2次
        int ans = 0;
        for (int num : nums) {
            ans = ans ^ num;
        }
        for (int i = 0; i <= nums.length; i++) {
            ans = ans ^ i;
        }
        return ans;
    }

    /**
     * 4. 只出现一次的数字 III
     * 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
     * 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。
     * 示例 1：
     * 输入：nums = [1,2,1,3,2,5]
     * 输出：[3,5]
     * 解释：[5, 3] 也是有效的答案。
     * 示例 2：
     * 输入：nums = [-1,0]
     * 输出：[-1,0]
     * 示例 3：
     * 输入：nums = [0,1]
     * 输出：[1,0]
     */
    public int[] singleNumber3(int[] nums) {
        /*Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0)+1);
        }
        int[] ans = new int[2];
        int index = 0;
        for (Integer key : map.keySet()) {
            int val = map.get(key);
            if (val != 2) {
                ans[index++] = key;
            }
            if (index == 2) break;
        }
        return ans;*/
        // TODO: 2022/12/30 位运算
        // 看到这种找不重复数字的，一般都是把数异或一遍，但是和之前不同的是，这次有两个只出现一次的数，直接异或得到的不是最终结果
        // 而是2个出现一次的数的异或，这时要考虑后续的处理方法
        // 设这2个数为a，b，结果c = a^b
        // 1. 找到c最右侧的1，假设是在第l位，则a和b 2个数有一个数的第l位是1，另一个是0，这样异或完之后，结果才是1
        // 2. 可以把nums中的元素分为2类，第l位是1的 和 第l位不是1的
        // 3. 对于出现2次的数，一定会分在同一类中；而a和b一定出现在不同类中，这样对两类分别异或，就能得到a和b
        int diff = 0;
        for (int num : nums) {
            diff ^= num;
        }
        diff &= -diff;  // 得到最右侧的1
        // 防止溢出
        int lsb = (diff == Integer.MIN_VALUE ? diff : diff & (-diff));

        int type1 = 0, type2 = 0;
        for (int num : nums) {
            if ((num & lsb) == 0) { // 说明num第l位是0，应该放到第一类异或
                type1 ^= num;
            }
            else { // 说明num第l位是1，应该放到第二类异或
                type2 ^= num;
            }
        }
        return new int[]{type1, type2};
    }

    /**
     * 5. 颠倒二进制位
     * 颠倒给定的 32 位无符号整数的二进制位。
     * 提示：
     * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，
     * 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
     * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
     * 示例 1：
     * 输入：n = 00000010100101000001111010011100
     * 输出：964176192 (00111001011110000010100101000000)
     * 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     *      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
     * 示例 2：
     * 输入：n = 11111111111111111111111111111101
     * 输出：3221225471 (10111111111111111111111111111111)
     * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     *      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
     */
    // you need treat n as an unsigned value
    public int reverseBits(int n) { // TODO: 2022/12/30
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            ret <<= 1;
            ret |= (n & 1); // n&1 获取n的最低一位，和0或之后还是自己，也就是取出n的最后一位放到ret中，ret左移，n右移
            n >>>= 1;
        }
        return ret;
    }

    /**
     * 7. 不用额外变量交换两个整数
     * a = a ^ b;
     * b = a ^ b;
     * a = a ^ b;
     */

    /**
     * 8. 2 的幂
     * 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
     * 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。
     * 示例 1：
     * 输入：n = 1
     * 输出：true
     * 解释：20 = 1
     * 示例 2：
     * 输入：n = 16
     * 输出：true
     * 解释：24 = 16
     * 示例 3：
     * 输入：n = 3
     * 输出：false
     * 示例 4：
     * 输入：n = 4
     * 输出：true
     * 示例 5：
     * 输入：n = 5
     * 输出：false
     */
    public boolean isPowerOfTwo(int n) {
        // TODO: 2022/12/30 一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1
//        return n > 0 && Integer.bitCount(n) == 1;
        // 不使用API
        // 1. n & (n - 1) 可以将n最低位的1移除，因此若移除后为0，则表示n中只有一个1，满足条件
//        return n > 0 && (n&(n-1)) == 0;
        // 2. n & (-n) 可以获得n最低位的1，因此如果获取最低位的1和n相等，说明n中只有一个1，满足条件
        return n > 0 && (n&(-n)) == n;
    }










}
